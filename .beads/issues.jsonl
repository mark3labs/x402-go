{"id":"x402-go-1","title":"Remove DEBUG log statements from production code","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T17:25:43.770299599+03:00","updated_at":"2025-10-29T20:14:38.315218628+03:00","closed_at":"2025-10-29T20:14:38.315218628+03:00"}
{"id":"x402-go-10","title":"Add godoc package documentation for all public packages","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T17:26:00.049130692+03:00","updated_at":"2025-10-29T17:26:00.049130692+03:00"}
{"id":"x402-go-11","title":"types.go AmountToBigInt silently discards accuracy information","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T17:26:00.871179508+03:00","updated_at":"2025-10-29T20:14:36.210574163+03:00","closed_at":"2025-10-29T20:14:36.210574163+03:00"}
{"id":"x402-go-12","title":"http/client.go GetSettlement silently returns nil on parse errors","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T17:26:01.295078602+03:00","updated_at":"2025-10-29T20:14:35.399267019+03:00","closed_at":"2025-10-29T20:14:35.399267019+03:00"}
{"id":"x402-go-13","title":"http/facilitator.go should have configurable retry logic for facilitator failures","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-29T17:26:01.361852264+03:00","updated_at":"2025-10-29T20:14:34.460462839+03:00","closed_at":"2025-10-29T20:14:34.460462839+03:00"}
{"id":"x402-go-14","title":"Refactor HTTP and MCP packages for code reuse and consistency","description":"","status":"open","priority":1,"issue_type":"epic","created_at":"2025-11-01T14:27:32.34606874+03:00","updated_at":"2025-11-01T14:27:32.34606874+03:00"}
{"id":"x402-go-15","title":"Create shared Facilitator interface in root package","description":"","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-01T14:27:37.118388232+03:00","updated_at":"2025-11-01T14:39:01.072759225+03:00","closed_at":"2025-11-01T14:39:01.072759225+03:00"}
{"id":"x402-go-16","title":"Create shared Facilitator interface in root package","description":"## Objective\nCreate a shared Facilitator interface and common response types that both HTTP and MCP packages can use, eliminating duplicate type definitions.\n\n## Current State\n- VerifyResponse type duplicated in http/facilitator.go:33-38 and mcp/types.go:43-48\n- Each package has its own facilitator implementation with no shared interface\n- MCP wraps HTTP facilitator but could implement the interface directly\n\n## Implementation Details\n\n### 1. Create new file: x402/facilitator/interface.go\n```go\npackage facilitator\n\nimport (\n    \"context\"\n    \"github.com/mark3labs/x402-go\"\n)\n\n// Interface defines the standard facilitator contract\ntype Interface interface {\n    Verify(ctx context.Context, payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*VerifyResponse, error)\n    Settle(ctx context.Context, payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*x402.SettlementResponse, error)\n    Supported(ctx context.Context) (*SupportedResponse, error)\n}\n\n// VerifyResponse contains the payment verification result\ntype VerifyResponse struct {\n    IsValid       bool   `json:\"isValid\"`\n    InvalidReason string `json:\"invalidReason,omitempty\"`\n    Payer         string `json:\"payer\"`\n}\n\n// SupportedKind describes a supported payment type\ntype SupportedKind struct {\n    X402Version int                    `json:\"x402Version\"`\n    Scheme      string                 `json:\"scheme\"`\n    Network     string                 `json:\"network\"`\n    Extra       map[string]interface{} `json:\"extra,omitempty\"`\n}\n\n// SupportedResponse lists all supported payment types\ntype SupportedResponse struct {\n    Kinds []SupportedKind `json:\"kinds\"`\n}\n```\n\n### 2. Update http/facilitator.go\n- Remove local VerifyResponse type (lines 33-38)\n- Remove local SupportedKind and SupportedResponse types (lines 93-104)\n- Import \"github.com/mark3labs/x402-go/facilitator\"\n- Update FacilitatorClient methods to accept context.Context as first parameter\n- Return facilitator.VerifyResponse instead of local type\n- Implement facilitator.Interface\n\n### 3. Update mcp/types.go\n- Remove duplicate VerifyResponse type (lines 43-48)\n- Import facilitator types where needed\n\n### 4. Update mcp/server/facilitator.go\n- Change Facilitator interface to embed x402/facilitator.Interface\n- Update HTTPFacilitator to use shared types\n- Remove type conversion in Verify method (lines 50-54)\n\n## Testing Requirements\n- Verify all existing tests pass\n- Add interface compliance test for both implementations\n- Test context cancellation behavior\n- Ensure JSON marshaling remains unchanged\n\n## Acceptance Criteria\n- [ ] Single VerifyResponse type used by both packages\n- [ ] Both facilitator implementations satisfy the same interface\n- [ ] Context parameter properly propagated in HTTP facilitator\n- [ ] All existing tests pass without modification\n- [ ] No changes to JSON wire format","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-01T14:27:40.702252293+03:00","updated_at":"2025-11-01T14:45:26.034638104+03:00","closed_at":"2025-11-01T14:45:26.034638104+03:00","dependencies":[{"issue_id":"x402-go-16","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:27:40.707077434+03:00","created_by":"daemon"}]}
{"id":"x402-go-17","title":"Standardize context handling in HTTP facilitator","description":"## Objective\nUpdate HTTP facilitator to accept context.Context as the first parameter in all methods, matching MCP's pattern and enabling proper cancellation/timeout control.\n\n## Current State\n- HTTP facilitator creates contexts internally: http/facilitator.go:57\n- MCP facilitator accepts context but doesn't use it: mcp/server/facilitator.go:43\n- Users cannot control timeouts or cancel operations\n\n## Implementation Details\n\n### 1. Update http/facilitator.go method signatures\n\n#### Before:\n```go\nfunc (c *FacilitatorClient) Verify(payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*VerifyResponse, error)\nfunc (c *FacilitatorClient) Settle(payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*x402.SettlementResponse, error)\nfunc (c *FacilitatorClient) Supported() (*SupportedResponse, error)\n```\n\n#### After:\n```go\nfunc (c *FacilitatorClient) Verify(ctx context.Context, payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*VerifyResponse, error)\nfunc (c *FacilitatorClient) Settle(ctx context.Context, payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*x402.SettlementResponse, error)\nfunc (c *FacilitatorClient) Supported(ctx context.Context) (*SupportedResponse, error)\n```\n\n### 2. Update timeout handling\n\n#### Current (line 57):\n```go\nctx, cancel := context.WithTimeout(context.Background(), c.VerifyTimeout)\ndefer cancel()\n```\n\n#### New approach:\n```go\n// Use provided context, apply timeout only if not already set\nif _, hasDeadline := ctx.Deadline(); !hasDeadline \u0026\u0026 c.VerifyTimeout \u003e 0 {\n    var cancel context.CancelFunc\n    ctx, cancel = context.WithTimeout(ctx, c.VerifyTimeout)\n    defer cancel()\n}\n```\n\n### 3. Update all callers\n- http/middleware.go: Pass request context to facilitator\n- http/handler.go: Pass context through helper functions\n- Update test files to pass context.Background() or context.TODO()\n\n### 4. Update MCP wrapper\n- Remove comment about context not being accepted\n- Pass context through to HTTP facilitator\n\n## Breaking Change Mitigation\nThis is a breaking change. Consider:\n1. Adding deprecated methods that call new ones with context.Background()\n2. Document migration path in CHANGELOG\n3. Update all examples\n\n## Testing Requirements\n- Test context cancellation propagates correctly\n- Test timeout behavior with and without deadline in context\n- Test backwards compatibility if deprecated methods added\n- Verify MCP wrapper works with context\n\n## Acceptance Criteria\n- [ ] All facilitator methods accept context as first parameter\n- [ ] Context cancellation properly handled\n- [ ] Timeouts respect existing context deadlines\n- [ ] All tests updated and passing\n- [ ] Breaking change documented\n- [ ] Migration guide provided","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-01T14:28:10.032425329+03:00","updated_at":"2025-11-01T14:46:02.95825757+03:00","closed_at":"2025-11-01T14:46:02.95825757+03:00","dependencies":[{"issue_id":"x402-go-17","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:28:10.037099979+03:00","created_by":"daemon"},{"issue_id":"x402-go-17","depends_on_id":"x402-go-16","type":"blocks","created_at":"2025-11-01T14:28:10.041175755+03:00","created_by":"daemon"}]}
{"id":"x402-go-18","title":"Consolidate error definitions across packages","description":"## Objective\nEliminate duplicate error definitions between packages by using root package errors everywhere, reducing ~20 error definitions to ~10.\n\n## Current State\nDuplicate errors exist:\n- x402.ErrFacilitatorUnavailable (line 44) vs mcp.ErrFacilitatorUnavailable (line 48)\n- x402.ErrVerificationFailed (line 46) vs mcp.ErrPaymentRejected (line 24)\n- x402.ErrSettlementFailed (line 59) vs mcp.ErrSettlementFailed (line 27)\n- x402.ErrNoValidSigner (line 7) vs mcp.ErrNoMatchingSigner (line 18)\n\n## Implementation Details\n\n### 1. Audit all error usage\nCreate comprehensive list of where each error is used:\n- grep for all x402.Err* usage\n- grep for all mcp.Err* usage\n- Document semantic differences if any\n\n### 2. Update mcp/errors.go\nRemove duplicates and use root errors with context wrapping:\n\n#### Before:\n```go\nvar ErrFacilitatorUnavailable = errors.New(\"facilitator service unavailable\")\nreturn ErrFacilitatorUnavailable\n```\n\n#### After:\n```go\n// Remove the duplicate definition\nreturn fmt.Errorf(\"tool %s: %w\", toolName, x402.ErrFacilitatorUnavailable)\n```\n\n### 3. Update error checks\nFind and update all error checking code:\n\n#### Before:\n```go\nif errors.Is(err, mcp.ErrNoMatchingSigner) {\n```\n\n#### After:\n```go\nif errors.Is(err, x402.ErrNoValidSigner) {\n```\n\n### 4. Maintain MCP-specific errors\nKeep errors that are truly MCP-specific:\n- ErrPaymentRequired (MCP uses this for 402 signaling)\n- ErrInvalidMetadata (MCP-specific _meta field)\n- Keep MCP's PaymentError wrapper for adding tool/resource context\n\n### 5. Update documentation\nDocument error hierarchy:\n```\nRoot errors (x402 package):\n- ErrNoValidSigner\n- ErrFacilitatorUnavailable\n- ErrVerificationFailed\n- ErrSettlementFailed\n- ErrAmountExceeded\n- ErrUnsupportedScheme\n- ErrInvalidPayment\n\nMCP-specific errors:\n- ErrPaymentRequired (402 signaling)\n- ErrInvalidMetadata (_meta field issues)\n\nHTTP uses root errors directly or wraps with fmt.Errorf\nMCP wraps root errors with PaymentError for context\n```\n\n## Error Mapping Table\n| Current MCP Error | Root Package Equivalent | Action |\n|------------------|------------------------|--------|\n| ErrNoMatchingSigner | ErrNoValidSigner | Replace |\n| ErrFacilitatorUnavailable | ErrFacilitatorUnavailable | Replace |\n| ErrPaymentRejected | ErrVerificationFailed | Replace |\n| ErrSettlementFailed | ErrSettlementFailed | Replace |\n| ErrPaymentRequired | (none - MCP specific) | Keep |\n| ErrInvalidMetadata | (none - MCP specific) | Keep |\n\n## Testing Requirements\n- All error.Is() checks still work\n- Error unwrapping works correctly\n- Error messages remain informative\n- No breaking changes to error handling\n\n## Acceptance Criteria\n- [ ] No duplicate error definitions between packages\n- [ ] All errors properly wrapped with context\n- [ ] Error checking (errors.Is) works correctly\n- [ ] Documentation updated with error hierarchy\n- [ ] All tests pass","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-11-01T14:28:38.566316424+03:00","updated_at":"2025-11-01T14:47:54.913865895+03:00","closed_at":"2025-11-01T14:47:54.913865895+03:00","dependencies":[{"issue_id":"x402-go-18","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:28:38.571162774+03:00","created_by":"daemon"}]}
{"id":"x402-go-19","title":"Consolidate requirement matching logic","description":"## Objective\nEliminate duplicate FindMatchingRequirement logic by moving it to the root package, saving 11 lines of duplicate code.\n\n## Current State\nLogic duplicated in:\n- http/internal/helpers/helpers.go:46-57\n- mcp/server/handler.go:231-240\nBoth do identical scheme/network matching\n\n## Implementation Details\n\n### 1. Add to root package (x402/requirements.go)\n```go\n// FindMatchingRequirement finds a payment requirement that matches the given payment's scheme and network.\n// Returns an error if no matching requirement is found.\nfunc FindMatchingRequirement(payment PaymentPayload, requirements []PaymentRequirement) (*PaymentRequirement, error) {\n    for i := range requirements {\n        req := \u0026requirements[i]\n        if req.Network == payment.Network \u0026\u0026 req.Scheme == payment.Scheme {\n            return req, nil\n        }\n    }\n    return nil, fmt.Errorf(\"%w: no matching requirement for network=%s scheme=%s\", \n        ErrUnsupportedScheme, payment.Network, payment.Scheme)\n}\n```\n\n### 2. Update http/internal/helpers/helpers.go\nReplace lines 46-57 with:\n```go\nfunc FindMatchingRequirement(payment x402.PaymentPayload, requirements []x402.PaymentRequirement) (x402.PaymentRequirement, error) {\n    req, err := x402.FindMatchingRequirement(payment, requirements)\n    if err != nil {\n        return x402.PaymentRequirement{}, err\n    }\n    return *req, nil\n}\n```\n\nNote: Keep wrapper for backwards compatibility since it returns value instead of pointer.\n\n### 3. Update mcp/server/handler.go\nReplace lines 231-240 with:\n```go\nfunc (h *X402Handler) findMatchingRequirement(payment *x402.PaymentPayload, requirements []x402.PaymentRequirement) (*x402.PaymentRequirement, error) {\n    return x402.FindMatchingRequirement(*payment, requirements)\n}\n```\n\nOr remove the method entirely and call x402.FindMatchingRequirement directly.\n\n### 4. Add comprehensive tests\n```go\nfunc TestFindMatchingRequirement(t *testing.T) {\n    tests := []struct {\n        name         string\n        payment      PaymentPayload\n        requirements []PaymentRequirement\n        wantNetwork  string\n        wantScheme   string\n        wantErr      bool\n    }{\n        {\n            name: \"exact match\",\n            payment: PaymentPayload{Network: \"base\", Scheme: \"exact\"},\n            requirements: []PaymentRequirement{\n                {Network: \"polygon\", Scheme: \"exact\"},\n                {Network: \"base\", Scheme: \"exact\"},\n            },\n            wantNetwork: \"base\",\n            wantScheme: \"exact\",\n        },\n        {\n            name: \"no match\",\n            payment: PaymentPayload{Network: \"ethereum\", Scheme: \"exact\"},\n            requirements: []PaymentRequirement{\n                {Network: \"base\", Scheme: \"exact\"},\n            },\n            wantErr: true,\n        },\n    }\n    // ... test implementation\n}\n```\n\n## Backwards Compatibility\n- HTTP helper can keep its signature (returns value)\n- MCP can use root function directly (returns pointer)\n- No breaking changes to public APIs\n\n## Testing Requirements\n- Unit tests for various matching scenarios\n- Test error cases (no match found)\n- Verify both packages still work correctly\n- Benchmark performance (should be identical)\n\n## Acceptance Criteria\n- [ ] Function added to root package\n- [ ] HTTP package uses root function\n- [ ] MCP package uses root function\n- [ ] All existing tests pass\n- [ ] New tests added for root function\n- [ ] No duplicate implementations remain","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-01T14:29:12.184811373+03:00","updated_at":"2025-11-01T15:13:55.511504432+03:00","closed_at":"2025-11-01T15:13:55.511504432+03:00","dependencies":[{"issue_id":"x402-go-19","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:29:12.189684202+03:00","created_by":"daemon"}]}
{"id":"x402-go-2","title":"Error handling bug in handler.go sendPaymentRequiredWithRequirements","description":"","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-29T17:25:44.911411053+03:00","updated_at":"2025-10-29T17:30:51.891979853+03:00","closed_at":"2025-10-29T17:30:51.891979853+03:00"}
{"id":"x402-go-20","title":"Extract payment encoding/decoding utilities","description":"## Objective\nCreate shared utilities for payment and settlement encoding/decoding to eliminate duplicate JSON marshaling and base64 encoding logic.\n\n## Current State\nDuplicate encoding logic in:\n- http/transport.go:142-171 (buildPaymentHeader, parseSettlement)\n- mcp/client/transport.go:217-221 (payment marshaling for injection)\nSimilar patterns repeated with minor variations\n\n## Implementation Details\n\n### 1. Create new package: x402/encoding/encoding.go\n```go\npackage encoding\n\nimport (\n    \"encoding/base64\"\n    \"encoding/json\"\n    \"fmt\"\n    \"github.com/mark3labs/x402-go\"\n)\n\n// EncodePayment converts a PaymentPayload to base64-encoded JSON string.\n// Used for HTTP X-PAYMENT header and other transport encoding needs.\nfunc EncodePayment(payment x402.PaymentPayload) (string, error) {\n    paymentJSON, err := json.Marshal(payment)\n    if err != nil {\n        return \"\", fmt.Errorf(\"failed to marshal payment: %w\", err)\n    }\n    return base64.StdEncoding.EncodeToString(paymentJSON), nil\n}\n\n// DecodePayment converts a base64-encoded JSON string to PaymentPayload.\nfunc DecodePayment(encoded string) (x402.PaymentPayload, error) {\n    var payment x402.PaymentPayload\n    \n    decoded, err := base64.StdEncoding.DecodeString(encoded)\n    if err != nil {\n        return payment, fmt.Errorf(\"failed to decode base64: %w\", err)\n    }\n    \n    if err := json.Unmarshal(decoded, \u0026payment); err != nil {\n        return payment, fmt.Errorf(\"failed to unmarshal payment: %w\", err)\n    }\n    \n    return payment, nil\n}\n\n// EncodeSettlement converts a SettlementResponse to base64-encoded JSON string.\n// Used for HTTP X-PAYMENT-RESPONSE header.\nfunc EncodeSettlement(settlement x402.SettlementResponse) (string, error) {\n    settlementJSON, err := json.Marshal(settlement)\n    if err != nil {\n        return \"\", fmt.Errorf(\"failed to marshal settlement: %w\", err)\n    }\n    return base64.StdEncoding.EncodeToString(settlementJSON), nil\n}\n\n// DecodeSettlement converts a base64-encoded JSON string to SettlementResponse.\nfunc DecodeSettlement(encoded string) (x402.SettlementResponse, error) {\n    var settlement x402.SettlementResponse\n    \n    decoded, err := base64.StdEncoding.DecodeString(encoded)\n    if err != nil {\n        return settlement, fmt.Errorf(\"failed to decode base64: %w\", err)\n    }\n    \n    if err := json.Unmarshal(decoded, \u0026settlement); err != nil {\n        return settlement, fmt.Errorf(\"failed to unmarshal settlement: %w\", err)\n    }\n    \n    return settlement, nil\n}\n\n// EncodeRequirements converts PaymentRequirementsResponse to base64-encoded JSON.\nfunc EncodeRequirements(requirements x402.PaymentRequirementsResponse) (string, error) {\n    reqJSON, err := json.Marshal(requirements)\n    if err != nil {\n        return \"\", fmt.Errorf(\"failed to marshal requirements: %w\", err)\n    }\n    return base64.StdEncoding.EncodeToString(reqJSON), nil\n}\n\n// DecodeRequirements converts base64-encoded JSON to PaymentRequirementsResponse.\nfunc DecodeRequirements(encoded string) (x402.PaymentRequirementsResponse, error) {\n    var requirements x402.PaymentRequirementsResponse\n    \n    decoded, err := base64.StdEncoding.DecodeString(encoded)\n    if err != nil {\n        return requirements, fmt.Errorf(\"failed to decode base64: %w\", err)\n    }\n    \n    if err := json.Unmarshal(decoded, \u0026requirements); err != nil {\n        return requirements, fmt.Errorf(\"failed to unmarshal requirements: %w\", err)\n    }\n    \n    return requirements, nil\n}\n```\n\n### 2. Update http/transport.go\nReplace buildPaymentHeader (lines 142-154):\n```go\nfunc (t *X402Transport) buildPaymentHeader(payment x402.PaymentPayload) (string, error) {\n    return encoding.EncodePayment(payment)\n}\n```\n\nReplace parseSettlement (lines 156-171):\n```go\nfunc parseSettlement(header string) (*x402.SettlementResponse, error) {\n    if header == \"\" {\n        return nil, nil\n    }\n    \n    settlement, err := encoding.DecodeSettlement(header)\n    if err != nil {\n        return nil, err\n    }\n    \n    return \u0026settlement, nil\n}\n```\n\n### 3. Update mcp/client/transport.go\nReplace inline marshaling (lines 217-221):\n```go\n// Instead of inline json.Marshal\npaymentJSON, err := json.Marshal(payment)\n\n// Use:\n// Note: MCP doesn't need base64, but can still use the marshal part\npaymentJSON, err := json.Marshal(payment)\n// Or consider adding a MarshalPayment helper that just does JSON without base64\n```\n\n### 4. Update http/internal/helpers/helpers.go\nUpdate AddPaymentResponseHeader to use encoding utilities.\n\n## Testing Requirements\n- Test all encoding/decoding functions with valid inputs\n- Test error cases (invalid base64, invalid JSON)\n- Test round-trip encoding/decoding\n- Verify backwards compatibility (same output format)\n- Benchmark performance\n\n## Acceptance Criteria\n- [ ] encoding package created with all utilities\n- [ ] HTTP package uses encoding utilities\n- [ ] All encoding/decoding centralized\n- [ ] Comprehensive tests for encoding package\n- [ ] No change to wire format (same base64/JSON output)\n- [ ] Performance equal or better","status":"closed","priority":2,"issue_type":"task","created_at":"2025-11-01T14:29:42.304432957+03:00","updated_at":"2025-11-01T15:18:00.196885098+03:00","closed_at":"2025-11-01T15:18:00.196885098+03:00","dependencies":[{"issue_id":"x402-go-20","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:29:42.311254974+03:00","created_by":"daemon"}]}
{"id":"x402-go-21","title":"Add payment lifecycle callbacks to HTTP package","description":"## Objective\nAdd payment lifecycle callbacks to HTTP package to enable logging and monitoring, matching MCP's callback capabilities.\n\n## Current State\n- MCP has callbacks: OnPaymentAttempt, OnPaymentSuccess, OnPaymentFailure (mcp/client/config.go:22-28)\n- HTTP has no callback mechanism\n- Users cannot hook into payment events for logging/monitoring\n\n## Implementation Details\n\n### 1. Define shared event types in root package (x402/events.go)\n```go\npackage x402\n\nimport \"time\"\n\n// PaymentEventType represents the type of payment event\ntype PaymentEventType string\n\nconst (\n    PaymentEventAttempt PaymentEventType = \"attempt\"\n    PaymentEventSuccess PaymentEventType = \"success\"\n    PaymentEventFailure PaymentEventType = \"failure\"\n)\n\n// PaymentEvent represents a payment lifecycle event\ntype PaymentEvent struct {\n    Type        PaymentEventType        // Event type\n    Timestamp   time.Time              // When the event occurred\n    Method      string                 // Transport method (\"HTTP\" or \"MCP\")\n    Tool        string                 // Tool/resource being accessed (MCP)\n    URL         string                 // URL being accessed (HTTP)\n    Amount      string                 // Payment amount\n    Asset       string                 // Asset address/identifier\n    Network     string                 // Network identifier\n    Scheme      string                 // Payment scheme\n    Recipient   string                 // Payment recipient\n    Payer       string                 // Payer address (on success)\n    Transaction string                 // Transaction hash (on success)\n    Error       error                  // Error details (on failure)\n    Duration    time.Duration          // Time taken for operation\n    Metadata    map[string]interface{} // Additional context\n}\n\n// PaymentCallback is a function that handles payment events\ntype PaymentCallback func(PaymentEvent)\n```\n\n### 2. Add callbacks to HTTP transport (http/transport.go)\n```go\ntype X402Transport struct {\n    Base              http.RoundTripper\n    Signers           []x402.Signer\n    Selector          x402.PaymentSelector\n    OnPaymentAttempt  x402.PaymentCallback\n    OnPaymentSuccess  x402.PaymentCallback\n    OnPaymentFailure  x402.PaymentCallback\n}\n\n// In RoundTrip method, add callback triggers:\nfunc (t *X402Transport) RoundTrip(req *http.Request) (*http.Response, error) {\n    // ... existing code ...\n    \n    // When payment required (line ~60)\n    if resp.StatusCode == http.StatusPaymentRequired {\n        startTime := time.Now()\n        \n        // Trigger attempt callback\n        if t.OnPaymentAttempt != nil {\n            event := x402.PaymentEvent{\n                Type:      x402.PaymentEventAttempt,\n                Timestamp: startTime,\n                Method:    \"HTTP\",\n                URL:       req.URL.String(),\n                Network:   payment.Network,\n                Scheme:    payment.Scheme,\n                Amount:    requirement.MaxAmountRequired,\n                Asset:     requirement.Asset,\n                Recipient: requirement.PayTo,\n            }\n            t.OnPaymentAttempt(event)\n        }\n        \n        // ... create and send payment ...\n        \n        // After retry (line ~84)\n        retryResp, err := t.Base.RoundTrip(retryReq)\n        duration := time.Since(startTime)\n        \n        if err != nil {\n            // Trigger failure callback\n            if t.OnPaymentFailure != nil {\n                event := x402.PaymentEvent{\n                    Type:      x402.PaymentEventFailure,\n                    Timestamp: time.Now(),\n                    Method:    \"HTTP\",\n                    URL:       req.URL.String(),\n                    Error:     err,\n                    Duration:  duration,\n                }\n                t.OnPaymentFailure(event)\n            }\n            return nil, err\n        }\n        \n        // Parse settlement response\n        settlement := parseSettlement(retryResp.Header.Get(\"X-PAYMENT-RESPONSE\"))\n        \n        if settlement != nil \u0026\u0026 settlement.Success {\n            // Trigger success callback\n            if t.OnPaymentSuccess != nil {\n                event := x402.PaymentEvent{\n                    Type:        x402.PaymentEventSuccess,\n                    Timestamp:   time.Now(),\n                    Method:      \"HTTP\",\n                    URL:         req.URL.String(),\n                    Transaction: settlement.Transaction,\n                    Payer:       settlement.Payer,\n                    Duration:    duration,\n                }\n                t.OnPaymentSuccess(event)\n            }\n        }\n    }\n}\n```\n\n### 3. Add client option (http/client.go)\n```go\n// WithPaymentCallback sets a callback for payment events\nfunc WithPaymentCallback(eventType x402.PaymentEventType, callback x402.PaymentCallback) ClientOption {\n    return func(c *Client) error {\n        transport := getOrCreateTransport(c)\n        \n        switch eventType {\n        case x402.PaymentEventAttempt:\n            transport.OnPaymentAttempt = callback\n        case x402.PaymentEventSuccess:\n            transport.OnPaymentSuccess = callback\n        case x402.PaymentEventFailure:\n            transport.OnPaymentFailure = callback\n        default:\n            return fmt.Errorf(\"unknown event type: %s\", eventType)\n        }\n        \n        return nil\n    }\n}\n\n// Convenience method for setting all callbacks at once\nfunc WithPaymentCallbacks(onAttempt, onSuccess, onFailure x402.PaymentCallback) ClientOption {\n    return func(c *Client) error {\n        transport := getOrCreateTransport(c)\n        transport.OnPaymentAttempt = onAttempt\n        transport.OnPaymentSuccess = onSuccess\n        transport.OnPaymentFailure = onFailure\n        return nil\n    }\n}\n```\n\n### 4. Update MCP to use shared types\nUpdate mcp/client/config.go to use x402.PaymentEvent instead of local type.\n\n### 5. Example usage\n```go\nclient, err := http.NewClient(\n    http.WithSigner(signer),\n    http.WithPaymentCallback(x402.PaymentEventAttempt, func(event x402.PaymentEvent) {\n        log.Printf(\"Payment attempt: %s to %s\", event.Amount, event.Recipient)\n    }),\n    http.WithPaymentCallback(x402.PaymentEventSuccess, func(event x402.PaymentEvent) {\n        log.Printf(\"Payment success: tx=%s\", event.Transaction)\n    }),\n    http.WithPaymentCallback(x402.PaymentEventFailure, func(event x402.PaymentEvent) {\n        log.Printf(\"Payment failed: %v\", event.Error)\n    }),\n)\n```\n\n## Testing Requirements\n- Test callbacks are triggered at correct times\n- Test callbacks with nil handlers (shouldn't panic)\n- Test event data is populated correctly\n- Test duration calculation\n- Verify callbacks don't affect normal operation\n\n## Acceptance Criteria\n- [ ] PaymentEvent type in root package\n- [ ] HTTP transport triggers callbacks\n- [ ] Client options for setting callbacks\n- [ ] MCP uses shared PaymentEvent type\n- [ ] Examples demonstrate callback usage\n- [ ] Tests verify callback behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-11-01T14:30:21.462687582+03:00","updated_at":"2025-11-01T15:25:31.99032951+03:00","closed_at":"2025-11-01T15:25:31.99032951+03:00","dependencies":[{"issue_id":"x402-go-21","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:30:21.466862452+03:00","created_by":"daemon"}]}
{"id":"x402-go-22","title":"Replace MCP USDC helpers with root package helpers","description":"## Objective\nRemove duplicate USDC helper functions from MCP package and use the existing root package helpers that provide better validation and automatic amount conversion.\n\n## Current State\n- Root package has comprehensive USDC helpers: chains.go:156-241\n  - NewUSDCTokenConfig() at line 163\n  - NewUSDCPaymentRequirement() at line 186\n  - Chain configurations with USDC addresses\n- MCP duplicates this: mcp/server/requirements.go:30-79\n  - RequireUSDCBase(), RequireUSDCBaseSepolia()\n  - RequireUSDCPolygon(), RequireUSDCSolana()\n\n## Key Differences\nRoot package helpers provide:\n- Automatic human-readable to atomic unit conversion\n- Input validation (address, amount)\n- EIP-3009 parameters for EVM chains\n- Consistent defaults (scheme, timeout, mimeType)\n\nMCP helpers:\n- Require pre-converted atomic amounts\n- No validation\n- Missing EIP-3009 parameters\n- Manual configuration\n\n## Implementation Details\n\n### 1. First enhance root package config (x402/chains.go)\nAdd Description field to USDCRequirementConfig:\n```go\n// Around line 50\ntype USDCRequirementConfig struct {\n    Chain             ChainConfig\n    RecipientAddress  string\n    Amount            string\n    Description       string  // ADD THIS FIELD\n    Scheme            string\n    MaxTimeoutSeconds uint32\n    MimeType          string\n}\n\n// Update NewUSDCPaymentRequirement around line 222\nreq := PaymentRequirement{\n    Scheme:            scheme,\n    Network:           config.Chain.NetworkID,\n    MaxAmountRequired: atomicString,\n    Asset:             config.Chain.USDCAddress,\n    PayTo:             config.RecipientAddress,\n    Description:       config.Description,  // ADD THIS LINE\n    MimeType:          mimeType,\n    MaxTimeoutSeconds: int(maxTimeout),\n}\n```\n\n### 2. Remove MCP helper functions\nDelete from mcp/server/requirements.go:\n- Lines 29-40: RequireUSDCBase\n- Lines 42-53: RequireUSDCBaseSepolia\n- Lines 55-66: RequireUSDCPolygon\n- Lines 68-79: RequireUSDCSolana\n\n### 3. Update MCP examples\nReplace in examples/mcp/main.go:\n\n#### Before (line 65-74):\n```go\ncase \"base-sepolia\":\n    requirement = server.RequireUSDCBaseSepolia\ncase \"base\":\n    requirement = server.RequireUSDCBase\ncase \"polygon\":\n    requirement = server.RequireUSDCPolygon\ncase \"solana\":\n    requirement = server.RequireUSDCSolana\n```\n\n#### After:\n```go\n// At top of file, create helper\nfunc createUSDCRequirement(chain x402.ChainConfig, payTo, amount, description string) x402.PaymentRequirement {\n    req, err := x402.NewUSDCPaymentRequirement(x402.USDCRequirementConfig{\n        Chain:            chain,\n        RecipientAddress: payTo,\n        Amount:           amount,  // Now in human-readable format!\n        Description:      description,\n    })\n    if err != nil {\n        log.Fatalf(\"Failed to create requirement: %v\", err)\n    }\n    return req\n}\n\n// In switch statement:\ncase \"base-sepolia\":\n    requirement = func(payTo, _, desc string) x402.PaymentRequirement {\n        return createUSDCRequirement(x402.BaseSepolia, payTo, \"0.01\", desc)\n    }\ncase \"base\":\n    requirement = func(payTo, _, desc string) x402.PaymentRequirement {\n        return createUSDCRequirement(x402.BaseMainnet, payTo, \"0.01\", desc)\n    }\ncase \"polygon\":\n    requirement = func(payTo, _, desc string) x402.PaymentRequirement {\n        return createUSDCRequirement(x402.PolygonMainnet, payTo, \"0.01\", desc)\n    }\ncase \"solana\":\n    requirement = func(payTo, _, desc string) x402.PaymentRequirement {\n        return createUSDCRequirement(x402.SolanaMainnet, payTo, \"0.01\", desc)\n    }\n```\n\n### 4. Update amount handling\nChange line 107 to use human-readable amount:\n```go\n// Before:\nrequirement(*payTo, \"10000\", \"Premium search - 0.01 USDC\")\n\n// After:\nrequirement(*payTo, \"0.01\", \"Premium search - 0.01 USDC\")\n```\n\n### 5. Benefits of this change\nDocument in code comments:\n- Automatic amount conversion (0.01 → 10000)\n- Address validation\n- EIP-3009 parameters added automatically\n- Consistent with HTTP package usage\n- Single source of truth for USDC addresses\n\n## Testing Requirements\n- Verify MCP examples still work\n- Test amount conversion (0.01 USDC = 10000 atomic)\n- Verify EIP-3009 extra field is populated for EVM chains\n- Test validation catches invalid addresses\n- Compare JSON output before/after (should be identical except extra field)\n\n## Migration Guide for Users\n```go\n// Old way (MCP package):\nreq := server.RequireUSDCBase(recipientAddr, \"10000\", \"description\")\n\n// New way (root package):\nreq, err := x402.NewUSDCPaymentRequirement(x402.USDCRequirementConfig{\n    Chain:            x402.BaseMainnet,\n    RecipientAddress: recipientAddr,\n    Amount:           \"0.01\",  // Human readable!\n    Description:      \"description\",\n})\n```\n\n## Acceptance Criteria\n- [ ] Description field added to USDCRequirementConfig\n- [ ] MCP helper functions removed\n- [ ] All MCP examples updated\n- [ ] Tests pass with new implementation\n- [ ] EIP-3009 parameters properly added\n- [ ] Migration guide in CHANGELOG","status":"open","priority":2,"issue_type":"task","created_at":"2025-11-01T14:31:07.505053547+03:00","updated_at":"2025-11-01T14:31:48.704079439+03:00","dependencies":[{"issue_id":"x402-go-22","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:31:07.509662555+03:00","created_by":"daemon"}]}
{"id":"x402-go-23","title":"Extract retry logic to shared utility","description":"## Objective\nExtract the retry logic from HTTP facilitator into a reusable generic utility that both packages can use.\n\n## Current State\n- HTTP facilitator has custom retry logic: http/facilitator.go:224-291\n  - doWithRetry() at lines 224-257\n  - doSettleWithRetry() at lines 260-291\n- Retry logic with exponential backoff duplicated\n\n## Implementation Details\n\n### 1. Create generic retry package (x402/retry/retry.go)\n```go\npackage retry\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\n// Config holds retry configuration\ntype Config struct {\n    MaxAttempts int\n    InitialDelay time.Duration\n    MaxDelay     time.Duration\n    Multiplier   float64\n}\n\n// DefaultConfig provides sensible defaults\nvar DefaultConfig = Config{\n    MaxAttempts:  3,\n    InitialDelay: 100 * time.Millisecond,\n    MaxDelay:     5 * time.Second,\n    Multiplier:   2.0,\n}\n\n// IsRetryable determines if an error should trigger a retry\ntype IsRetryable func(error) bool\n\n// WithRetry executes a function with retry logic using generics for type safety\nfunc WithRetry[T any](\n    ctx context.Context,\n    config Config,\n    isRetryable IsRetryable,\n    fn func() (T, error),\n) (T, error) {\n    var zero T\n    var lastErr error\n    delay := config.InitialDelay\n    \n    for attempt := 0; attempt \u003c config.MaxAttempts; attempt++ {\n        // Check context before attempt\n        if err := ctx.Err(); err != nil {\n            return zero, fmt.Errorf(\"context cancelled: %w\", err)\n        }\n        \n        result, err := fn()\n        if err == nil {\n            return result, nil\n        }\n        \n        lastErr = err\n        \n        // Check if error is retryable\n        if !isRetryable(err) {\n            return zero, err\n        }\n        \n        // Don't sleep after last attempt\n        if attempt \u003c config.MaxAttempts-1 {\n            // Apply exponential backoff\n            select {\n            case \u003c-time.After(delay):\n                delay = time.Duration(float64(delay) * config.Multiplier)\n                if delay \u003e config.MaxDelay {\n                    delay = config.MaxDelay\n                }\n            case \u003c-ctx.Done():\n                return zero, ctx.Err()\n            }\n        }\n    }\n    \n    return zero, fmt.Errorf(\"max retries exceeded: %w\", lastErr)\n}\n\n// WithSimpleRetry uses default configuration\nfunc WithSimpleRetry[T any](\n    ctx context.Context,\n    fn func() (T, error),\n    isRetryable IsRetryable,\n) (T, error) {\n    return WithRetry(ctx, DefaultConfig, isRetryable, fn)\n}\n```\n\n### 2. Update HTTP facilitator to use retry utility\nReplace doWithRetry (lines 224-257):\n```go\nfunc (c *FacilitatorClient) doWithRetry(ctx context.Context, req *http.Request) (*http.Response, error) {\n    config := retry.Config{\n        MaxAttempts:  c.MaxRetries,\n        InitialDelay: c.RetryDelay,\n        MaxDelay:     c.RetryDelay * 4,\n        Multiplier:   2.0,\n    }\n    \n    return retry.WithRetry(ctx, config, isFacilitatorUnavailableError, func() (*http.Response, error) {\n        // Clone request for each attempt\n        clonedReq := req.Clone(ctx)\n        if req.Body != nil {\n            // Handle body cloning if needed\n        }\n        \n        resp, err := c.Client.Do(clonedReq)\n        if err != nil {\n            return nil, err\n        }\n        \n        // Check for retryable HTTP status codes\n        if resp.StatusCode \u003e= 500 {\n            resp.Body.Close()\n            return nil, fmt.Errorf(\"server error: %d\", resp.StatusCode)\n        }\n        \n        return resp, nil\n    })\n}\n```\n\n### 3. Benefits of generic approach\n- Type-safe with generics\n- Reusable across different return types\n- Context-aware with cancellation support\n- Configurable backoff strategy\n- Clean separation of retry logic from business logic\n\n### 4. Add tests for retry package\n```go\nfunc TestWithRetry(t *testing.T) {\n    t.Run(\"succeeds on first attempt\", func(t *testing.T) {\n        calls := 0\n        result, err := WithSimpleRetry(context.Background(), \n            func() (string, error) {\n                calls++\n                return \"success\", nil\n            },\n            func(error) bool { return true },\n        )\n        \n        assert.NoError(t, err)\n        assert.Equal(t, \"success\", result)\n        assert.Equal(t, 1, calls)\n    })\n    \n    t.Run(\"retries on retryable error\", func(t *testing.T) {\n        calls := 0\n        result, err := WithSimpleRetry(context.Background(),\n            func() (string, error) {\n                calls++\n                if calls \u003c 3 {\n                    return \"\", fmt.Errorf(\"temporary error\")\n                }\n                return \"success\", nil\n            },\n            func(error) bool { return true },\n        )\n        \n        assert.NoError(t, err)\n        assert.Equal(t, \"success\", result)\n        assert.Equal(t, 3, calls)\n    })\n    \n    t.Run(\"respects context cancellation\", func(t *testing.T) {\n        ctx, cancel := context.WithCancel(context.Background())\n        cancel() // Cancel immediately\n        \n        _, err := WithSimpleRetry(ctx,\n            func() (string, error) {\n                return \"\", fmt.Errorf(\"error\")\n            },\n            func(error) bool { return true },\n        )\n        \n        assert.Error(t, err)\n        assert.Contains(t, err.Error(), \"context cancelled\")\n    })\n}\n```\n\n## Testing Requirements\n- Unit tests for retry logic\n- Test exponential backoff timing\n- Test context cancellation\n- Test max retry limits\n- Benchmark performance vs existing implementation\n\n## Acceptance Criteria\n- [ ] Generic retry package created\n- [ ] HTTP facilitator uses retry package\n- [ ] Tests for retry package\n- [ ] Performance equal or better\n- [ ] Documentation with usage examples","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-01T14:31:54.91747019+03:00","updated_at":"2025-11-01T14:32:29.759044939+03:00","dependencies":[{"issue_id":"x402-go-23","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:31:54.921937745+03:00","created_by":"daemon"}]}
{"id":"x402-go-24","title":"Remove unnecessary MCP type aliases","description":"## Objective\nRemove redundant type aliases from MCP package that add no value and create confusion. Use x402 types directly instead.\n\n## Current State\nMCP has unnecessary type aliases in mcp/types.go:10-24:\n```go\ntype PaymentRequirement = x402.PaymentRequirement\ntype PaymentRequirements []PaymentRequirement\ntype PaymentPayload = x402.PaymentPayload\ntype SettlementResponse = x402.SettlementResponse\ntype TokenConfig = x402.TokenConfig\ntype Signer = x402.Signer\ntype PaymentSelector = x402.PaymentSelector\n```\n\nThese are pure pass-through aliases that:\n- Don't add any MCP-specific fields\n- Don't change behavior\n- Create confusion about which type to use\n- Still require importing x402 package\n\n## Implementation Details\n\n### 1. Remove aliases from mcp/types.go\nDelete lines 10-24, keeping only MCP-specific types:\n- PaymentRequirements (the slice type for 402 errors)\n- VerifyResponse (if not moved to shared facilitator package)\n- MCP-specific constants\n\n### 2. Update all MCP files to use x402 types directly\n\n#### mcp/server/handler.go\n```go\n// Before:\nfunc (h *X402Handler) findMatchingRequirement(payment *PaymentPayload, requirements []PaymentRequirement) (*PaymentRequirement, error)\n\n// After:\nfunc (h *X402Handler) findMatchingRequirement(payment *x402.PaymentPayload, requirements []x402.PaymentRequirement) (*x402.PaymentRequirement, error)\n```\n\n#### mcp/server/facilitator.go\n```go\n// Before:\nfunc (f *HTTPFacilitator) Verify(ctx context.Context, payment PaymentPayload, requirement PaymentRequirement) (*VerifyResponse, error)\n\n// After:\nfunc (f *HTTPFacilitator) Verify(ctx context.Context, payment x402.PaymentPayload, requirement x402.PaymentRequirement) (*VerifyResponse, error)\n```\n\n#### mcp/client/config.go\n```go\n// Before:\nSigners  []Signer\nSelector PaymentSelector\n\n// After:\nSigners  []x402.Signer\nSelector x402.PaymentSelector\n```\n\n### 3. Update function signatures\nSearch and replace throughout MCP package:\n- mcp.PaymentRequirement → x402.PaymentRequirement\n- mcp.PaymentPayload → x402.PaymentPayload\n- mcp.SettlementResponse → x402.SettlementResponse\n- mcp.Signer → x402.Signer\n- mcp.PaymentSelector → x402.PaymentSelector\n- mcp.TokenConfig → x402.TokenConfig\n\n### 4. Update imports\nAdd explicit x402 imports where needed:\n```go\nimport (\n    \"github.com/mark3labs/x402-go\"\n    // ... other imports\n)\n```\n\n### 5. Keep MCP-specific types\nRetain types that are actually MCP-specific:\n```go\n// PaymentRequirements is the structure for 402 error responses in MCP\ntype PaymentRequirements struct {\n    X402Version int                        `json:\"x402Version\"`\n    Error       string                     `json:\"error\"`\n    Accepts     []x402.PaymentRequirement  `json:\"accepts\"`\n}\n```\n\n## Benefits\n- Clearer code - obvious when using root types\n- Reduced confusion - one canonical type location\n- Better IDE support - go to definition works properly\n- Smaller API surface - fewer types to understand\n\n## Testing Requirements\n- Ensure all tests still compile\n- Verify JSON marshaling unchanged\n- Check examples still work\n- No runtime behavior changes\n\n## Migration Impact\nThis is a breaking change for MCP package users who reference these types.\n\nMigration path:\n```go\n// Before:\nvar signer mcp.Signer\n\n// After:\nvar signer x402.Signer\n```\n\n## Acceptance Criteria\n- [ ] Type aliases removed from mcp/types.go\n- [ ] All MCP files use x402 types directly\n- [ ] Tests pass without modification\n- [ ] Examples updated to use x402 types\n- [ ] Migration guide in CHANGELOG","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-01T14:32:35.976869756+03:00","updated_at":"2025-11-01T14:33:07.070586129+03:00","dependencies":[{"issue_id":"x402-go-24","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:32:35.981317985+03:00","created_by":"daemon"}]}
{"id":"x402-go-25","title":"Unify timeout configuration","description":"## Objective\nCreate a unified timeout configuration structure that both HTTP and MCP packages can use, eliminating inconsistency between constants and struct fields.\n\n## Current State\n- MCP uses constants: mcp/types.go:28-33\n  ```go\n  const (\n      PaymentVerifyTimeout = 5 * time.Second\n      PaymentSettleTimeout = 60 * time.Second\n  )\n  ```\n- HTTP uses struct fields: http/facilitator.go:20-21\n  ```go\n  VerifyTimeout time.Duration\n  SettleTimeout time.Duration\n  ```\n\n## Implementation Details\n\n### 1. Create unified config in root package (x402/config.go)\n```go\npackage x402\n\nimport \"time\"\n\n// TimeoutConfig holds timeout configuration for payment operations\ntype TimeoutConfig struct {\n    // VerifyTimeout is the maximum time to wait for payment verification\n    VerifyTimeout time.Duration\n    \n    // SettleTimeout is the maximum time to wait for payment settlement\n    SettleTimeout time.Duration\n    \n    // RequestTimeout is the overall timeout for HTTP requests (optional)\n    RequestTimeout time.Duration\n}\n\n// DefaultTimeouts provides sensible defaults for payment operations\nvar DefaultTimeouts = TimeoutConfig{\n    VerifyTimeout:  5 * time.Second,\n    SettleTimeout:  60 * time.Second,\n    RequestTimeout: 120 * time.Second,\n}\n\n// WithVerifyTimeout returns a new TimeoutConfig with updated verify timeout\nfunc (tc TimeoutConfig) WithVerifyTimeout(d time.Duration) TimeoutConfig {\n    tc.VerifyTimeout = d\n    return tc\n}\n\n// WithSettleTimeout returns a new TimeoutConfig with updated settle timeout\nfunc (tc TimeoutConfig) WithSettleTimeout(d time.Duration) TimeoutConfig {\n    tc.SettleTimeout = d\n    return tc\n}\n\n// Validate ensures timeout values are reasonable\nfunc (tc TimeoutConfig) Validate() error {\n    if tc.VerifyTimeout \u003c= 0 {\n        return fmt.Errorf(\"verify timeout must be positive, got %v\", tc.VerifyTimeout)\n    }\n    if tc.SettleTimeout \u003c= 0 {\n        return fmt.Errorf(\"settle timeout must be positive, got %v\", tc.SettleTimeout)\n    }\n    if tc.SettleTimeout \u003c tc.VerifyTimeout {\n        return fmt.Errorf(\"settle timeout (%v) should be \u003e= verify timeout (%v)\", \n            tc.SettleTimeout, tc.VerifyTimeout)\n    }\n    return nil\n}\n```\n\n### 2. Update HTTP facilitator\n```go\n// http/facilitator.go\ntype FacilitatorClient struct {\n    BaseURL  string\n    Client   *http.Client\n    Timeouts x402.TimeoutConfig  // Replace individual timeout fields\n    MaxRetries int\n    RetryDelay time.Duration\n}\n\n// NewFacilitatorClient constructor\nfunc NewFacilitatorClient(baseURL string, opts ...FacilitatorOption) *FacilitatorClient {\n    client := \u0026FacilitatorClient{\n        BaseURL:    baseURL,\n        Client:     \u0026http.Client{},\n        Timeouts:   x402.DefaultTimeouts,  // Use defaults\n        MaxRetries: 3,\n        RetryDelay: 100 * time.Millisecond,\n    }\n    \n    for _, opt := range opts {\n        opt(client)\n    }\n    \n    return client\n}\n\n// Add option for custom timeouts\nfunc WithTimeouts(timeouts x402.TimeoutConfig) FacilitatorOption {\n    return func(c *FacilitatorClient) {\n        c.Timeouts = timeouts\n    }\n}\n\n// In Verify method (line ~57):\nif _, hasDeadline := ctx.Deadline(); !hasDeadline \u0026\u0026 c.Timeouts.VerifyTimeout \u003e 0 {\n    ctx, cancel = context.WithTimeout(ctx, c.Timeouts.VerifyTimeout)\n    defer cancel()\n}\n\n// In Settle method:\nif _, hasDeadline := ctx.Deadline(); !hasDeadline \u0026\u0026 c.Timeouts.SettleTimeout \u003e 0 {\n    ctx, cancel = context.WithTimeout(ctx, c.Timeouts.SettleTimeout)\n    defer cancel()\n}\n```\n\n### 3. Update MCP to use config\n```go\n// mcp/types.go - remove constants (lines 28-33)\n// Remove:\n// const (\n//     PaymentVerifyTimeout = 5 * time.Second\n//     PaymentSettleTimeout = 60 * time.Second\n// )\n\n// mcp/server/facilitator.go\nfunc NewHTTPFacilitator(facilitatorURL string, timeouts ...x402.TimeoutConfig) *HTTPFacilitator {\n    config := x402.DefaultTimeouts\n    if len(timeouts) \u003e 0 {\n        config = timeouts[0]\n    }\n    \n    client := \u0026http.FacilitatorClient{\n        BaseURL:  facilitatorURL,\n        Client:   \u0026nethttp.Client{Timeout: config.RequestTimeout},\n        Timeouts: config,\n    }\n    \n    return \u0026HTTPFacilitator{client: client}\n}\n```\n\n### 4. Add builder pattern for custom configs\n```go\n// Example usage:\ncustomTimeouts := x402.DefaultTimeouts.\n    WithVerifyTimeout(10 * time.Second).\n    WithSettleTimeout(120 * time.Second)\n\nfacilitator := http.NewFacilitatorClient(url, \n    http.WithTimeouts(customTimeouts))\n```\n\n## Benefits\n- Single source of truth for timeout defaults\n- Consistent configuration across packages\n- Validation ensures reasonable values\n- Extensible for future timeout needs\n- Builder pattern for easy customization\n\n## Testing Requirements\n- Test timeout validation logic\n- Test builder methods\n- Verify both packages use same defaults\n- Test timeout behavior in both packages\n\n## Acceptance Criteria\n- [ ] TimeoutConfig created in root package\n- [ ] HTTP facilitator uses TimeoutConfig\n- [ ] MCP constants replaced with config\n- [ ] Default values consistent (5s verify, 60s settle)\n- [ ] Tests for validation logic\n- [ ] Examples show custom timeout usage","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-01T14:33:12.51680836+03:00","updated_at":"2025-11-01T14:33:46.551785403+03:00","dependencies":[{"issue_id":"x402-go-25","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:33:12.521688182+03:00","created_by":"daemon"}]}
{"id":"x402-go-26","title":"Share validation logic between packages","description":"## Objective\nMove MCP's validation logic to the root package so both HTTP and MCP can validate payment requirements before sending to facilitator.\n\n## Current State\n- MCP has extensive validation: mcp/server/requirements.go:83-165\n  - validateAmount() at lines 83-95\n  - validateEVMAddress() at lines 98-107\n  - validateNetwork() at lines 110-127\n  - ValidateRequirement() at lines 130-165\n- HTTP has no validation, relies entirely on facilitator\n\n## Implementation Details\n\n### 1. Create validation package (x402/validation/validation.go)\n```go\npackage validation\n\nimport (\n    \"fmt\"\n    \"regexp\"\n    \"strconv\"\n    \"strings\"\n    \"github.com/mark3labs/x402-go\"\n)\n\nvar (\n    // evmAddressRegex matches Ethereum-style addresses (0x followed by 40 hex chars)\n    evmAddressRegex = regexp.MustCompile(\"^0x[a-fA-F0-9]{40}$\")\n    \n    // solanaAddressRegex matches Solana base58 addresses (32-44 chars)\n    solanaAddressRegex = regexp.MustCompile(\"^[1-9A-HJ-NP-Za-km-z]{32,44}$\")\n)\n\n// ValidateAmount validates that an amount string is a valid non-negative integer\nfunc ValidateAmount(amount string) error {\n    if amount == \"\" {\n        return fmt.Errorf(\"amount cannot be empty\")\n    }\n    \n    val, err := strconv.ParseUint(amount, 10, 64)\n    if err != nil {\n        return fmt.Errorf(\"invalid amount format: %w\", err)\n    }\n    \n    // Allow zero for free-with-signature flows\n    if val == 0 {\n        // Log warning but allow\n        return nil\n    }\n    \n    return nil\n}\n\n// ValidateAddress validates an address based on the network type\nfunc ValidateAddress(address string, network string) error {\n    if address == \"\" {\n        return fmt.Errorf(\"address cannot be empty\")\n    }\n    \n    networkType, err := x402.ValidateNetwork(network)\n    if err != nil {\n        return fmt.Errorf(\"invalid network: %w\", err)\n    }\n    \n    switch networkType {\n    case x402.NetworkTypeEVM:\n        if !evmAddressRegex.MatchString(address) {\n            return fmt.Errorf(\"invalid EVM address format: %s\", address)\n        }\n        \n        // Additional checksum validation could go here\n        return nil\n        \n    case x402.NetworkTypeSVM:\n        if !solanaAddressRegex.MatchString(address) {\n            return fmt.Errorf(\"invalid Solana address format: %s\", address)\n        }\n        return nil\n        \n    default:\n        return fmt.Errorf(\"unsupported network type: %s\", networkType)\n    }\n}\n\n// ValidatePaymentRequirement performs comprehensive validation of a payment requirement\nfunc ValidatePaymentRequirement(req x402.PaymentRequirement) error {\n    // Validate amount\n    if err := ValidateAmount(req.MaxAmountRequired); err != nil {\n        return fmt.Errorf(\"invalid amount: %w\", err)\n    }\n    \n    // Validate network\n    if req.Network == \"\" {\n        return fmt.Errorf(\"network cannot be empty\")\n    }\n    \n    networkType, err := x402.ValidateNetwork(req.Network)\n    if err != nil {\n        return fmt.Errorf(\"invalid network: %w\", err)\n    }\n    \n    // Validate recipient address\n    if err := ValidateAddress(req.PayTo, req.Network); err != nil {\n        return fmt.Errorf(\"invalid payTo address: %w\", err)\n    }\n    \n    // Validate asset address\n    if req.Asset != \"\" {\n        if err := ValidateAddress(req.Asset, req.Network); err != nil {\n            return fmt.Errorf(\"invalid asset address: %w\", err)\n        }\n    }\n    \n    // Validate scheme\n    switch req.Scheme {\n    case \"exact\", \"max\", \"subscription\":\n        // Valid schemes\n    case \"\":\n        return fmt.Errorf(\"scheme cannot be empty\")\n    default:\n        return fmt.Errorf(\"unsupported scheme: %s\", req.Scheme)\n    }\n    \n    // Validate timeout\n    if req.MaxTimeoutSeconds \u003c 0 {\n        return fmt.Errorf(\"timeout cannot be negative: %d\", req.MaxTimeoutSeconds)\n    }\n    \n    // Validate EIP-3009 parameters for EVM chains\n    if networkType == x402.NetworkTypeEVM \u0026\u0026 req.Extra != nil {\n        if name, ok := req.Extra[\"name\"].(string); ok {\n            if name == \"\" {\n                return fmt.Errorf(\"EIP-3009 name cannot be empty\")\n            }\n        }\n        if version, ok := req.Extra[\"version\"].(string); ok {\n            if version == \"\" {\n                return fmt.Errorf(\"EIP-3009 version cannot be empty\")\n            }\n        }\n    }\n    \n    return nil\n}\n\n// ValidatePaymentPayload validates a payment payload\nfunc ValidatePaymentPayload(payment x402.PaymentPayload) error {\n    if payment.X402Version != 1 {\n        return fmt.Errorf(\"unsupported x402 version: %d\", payment.X402Version)\n    }\n    \n    if payment.Scheme == \"\" {\n        return fmt.Errorf(\"scheme cannot be empty\")\n    }\n    \n    if payment.Network == \"\" {\n        return fmt.Errorf(\"network cannot be empty\")\n    }\n    \n    if payment.Payload == nil {\n        return fmt.Errorf(\"payload cannot be nil\")\n    }\n    \n    return nil\n}\n```\n\n### 2. Add to chains.go ValidateNetwork function (if not exists)\n```go\n// Around line 243\ntype NetworkType string\n\nconst (\n    NetworkTypeEVM NetworkType = \"evm\"\n    NetworkTypeSVM NetworkType = \"svm\"\n    NetworkTypeUnknown NetworkType = \"unknown\"\n)\n\nfunc ValidateNetwork(networkID string) (NetworkType, error) {\n    switch networkID {\n    case \"base\", \"base-sepolia\", \"polygon\", \"polygon-amoy\", \n         \"avalanche\", \"avalanche-fuji\", \"ethereum\", \"ethereum-sepolia\":\n        return NetworkTypeEVM, nil\n    case \"solana\", \"solana-devnet\":\n        return NetworkTypeSVM, nil\n    default:\n        return NetworkTypeUnknown, fmt.Errorf(\"unknown network: %s\", networkID)\n    }\n}\n```\n\n### 3. Update MCP to use shared validation\n```go\n// mcp/server/requirements.go\n// Remove local validation functions (lines 83-165)\n// Import validation package instead\n\nimport \"github.com/mark3labs/x402-go/validation\"\n\n// In handlers, use shared validation:\nif err := validation.ValidatePaymentRequirement(requirement); err != nil {\n    return nil, fmt.Errorf(\"invalid requirement: %w\", err)\n}\n```\n\n### 4. Add validation to HTTP package (optional)\n```go\n// http/middleware.go\n// Before sending to facilitator, validate:\nif err := validation.ValidatePaymentRequirement(requirement); err != nil {\n    // Log warning but don't fail - let facilitator decide\n    log.Printf(\"Warning: requirement validation failed: %v\", err)\n}\n```\n\n### 5. Add comprehensive tests\n```go\nfunc TestValidatePaymentRequirement(t *testing.T) {\n    tests := []struct {\n        name    string\n        req     x402.PaymentRequirement\n        wantErr bool\n    }{\n        {\n            name: \"valid EVM requirement\",\n            req: x402.PaymentRequirement{\n                Scheme:            \"exact\",\n                Network:           \"base\",\n                MaxAmountRequired: \"10000\",\n                Asset:             \"0x833589fcd6edb6e08f4c7c32d4f71b54bda02913\",\n                PayTo:             \"0x209693Bc6afc0C5328bA36FaF03C514EF312287C\",\n            },\n            wantErr: false,\n        },\n        {\n            name: \"invalid address\",\n            req: x402.PaymentRequirement{\n                Network: \"base\",\n                PayTo:   \"not-an-address\",\n            },\n            wantErr: true,\n        },\n    }\n    // ... test implementation\n}\n```\n\n## Benefits\n- Single source of truth for validation rules\n- Early detection of invalid requirements\n- Better error messages for users\n- Consistent validation across packages\n- Extensible for new network types\n\n## Testing Requirements\n- Test all validation functions\n- Test with valid and invalid inputs\n- Test network-specific validation\n- Ensure MCP behavior unchanged\n- Performance benchmarks\n\n## Acceptance Criteria\n- [ ] Validation package created in root\n- [ ] MCP uses shared validation\n- [ ] HTTP optionally uses validation\n- [ ] Comprehensive test coverage\n- [ ] No breaking changes to API","status":"open","priority":3,"issue_type":"task","created_at":"2025-11-01T14:33:52.323763807+03:00","updated_at":"2025-11-01T14:34:44.279091441+03:00","dependencies":[{"issue_id":"x402-go-26","depends_on_id":"x402-go-14","type":"parent-child","created_at":"2025-11-01T14:33:52.329201878+03:00","created_by":"daemon"}]}
{"id":"x402-go-3","title":"Potential case-sensitivity issue in token address matching","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-10-29T17:25:45.967861712+03:00","updated_at":"2025-10-29T20:14:39.09993865+03:00","closed_at":"2025-10-29T20:14:39.09993865+03:00"}
{"id":"x402-go-4","title":"DEBUG log statements should be removed or guarded by log level","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T17:25:52.122397206+03:00","updated_at":"2025-10-29T20:14:37.954623981+03:00","closed_at":"2025-10-29T20:14:37.954623981+03:00"}
{"id":"x402-go-5","title":"http/handler.go sendPaymentRequired has error handling bug after headers sent","description":"","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-29T17:25:53.303006718+03:00","updated_at":"2025-10-29T17:30:51.694604235+03:00","closed_at":"2025-10-29T17:30:51.694604235+03:00"}
{"id":"x402-go-6","title":"http/transport.go only uses first payment requirement, ignores others","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-29T17:25:54.586548474+03:00","updated_at":"2025-10-29T20:14:36.93246443+03:00","closed_at":"2025-10-29T20:14:36.93246443+03:00"}
{"id":"x402-go-7","title":"selector.go token address comparison may be case-sensitive (inconsistent with CanSign)","description":"","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-29T17:25:55.754248706+03:00","updated_at":"2025-10-29T17:29:38.542544877+03:00","closed_at":"2025-10-29T17:29:38.542544877+03:00"}
{"id":"x402-go-8","title":"evm/signer.go getChainID returns 0 for unknown networks (should error)","description":"","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-10-29T17:25:57.090133157+03:00","updated_at":"2025-10-29T17:30:50.968183492+03:00","closed_at":"2025-10-29T17:30:50.968183492+03:00"}
{"id":"x402-go-9","title":"Missing test coverage for examples/ directory","description":"","status":"open","priority":3,"issue_type":"task","created_at":"2025-10-29T17:25:58.153980412+03:00","updated_at":"2025-10-29T17:25:58.153980412+03:00"}
